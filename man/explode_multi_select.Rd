% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/explode_multi_select.R
\name{explode_multi_select}
\alias{explode_multi_select}
\title{Explode Multi-Select Variables into Dummy Codes}
\usage{
explode_multi_select(
  x,
  answer_separators = c(",", "|"),
  long_format = FALSE,
  na_is_none_of_the_above = TRUE
)
}
\arguments{
\item{x}{Character vector containing multi-select data. Each element may contain
multiple answers separated by either commas (`,`) or pipes (`|`).}

\item{answer_separators}{Character vector specifying separators to split answers.
Default is c(",", "|").}

\item{long_format}{Logical. If \code{TRUE}, returns data in long format with
three columns: \code{index}, \code{original}, and \code{variable} (name of
the dummy-coded variable) and \code{value} (binary indicator). If \code{FALSE},
returns wide format with one column per unique value.}

\item{na_is_none_of_the_above}{Logical. If \code{TRUE}, treats "NA" values as
"none of the above" (all dummy variables FALSE). If \code{FALSE}, treats "NA"
values as missing (all dummy variables NA).}
}
\value{
A data.table with either:
  - Wide format: one row per input element, one column per unique value (binary)
  - Long format: three columns (\code{index}, \code{original}, \code{variable}, \code{value})
  - Additional columns: \code{original} (original input) and \code{index} (row index)
}
\description{
Converts multi-select variables (where each observation can contain multiple values
separated by commas or pipes) into dummy-coded variables. Each unique value becomes
a binary column indicating presence (TRUE) or absence (FALSE) of that value.
}
\examples{
# Basic usage
x <- c("A,B", "B,C", "A,C", "A|B|C")
result <- explode_multi_select(x)

# With long format
result_long <- explode_multi_select(x, long_format = TRUE)

# With custom separators
x2 <- c("A;B", "B;C")
result2 <- explode_multi_select(x2, answer_separators = ";")
}
